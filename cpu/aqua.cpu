; AQUA CPU description.  -*- Scheme -*-
;
; This file is part of the GNU Binutils.
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
; MA 02110-1301, USA.

(include "simplify.inc")

; general architecture information
(define-arch
  (name aqua)
  (comment "AQUA architecture")
  (default-alignment forced)
  (insn-lsb0? #t)
  (machs aqua)
  (isas aqua)
)

(define-isa
  (name aqua)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
  (liw-insns 1)
  (parallel-insns 1)
)

(define-cpu
  (name aqua)
  (comment "aqua cpu family")
  (endian big)
  (word-bitsize 32)
  (parallel-insns 1)
)

(define-mach
  (name aqua)
  (comment "aqua cpu")
  (cpu aqua)
)

(define-model
  (name aqua)
  (comment "aqua")
  (mach aqua)
  (unit u-exec "Execution Unit" ()
	  1 1 ; issue done
	  () () () ()
  )
)

; Instruction fields
(dnf f-opcode       "opcode"         () 31 6)
(dnf f-ra           "ra"             () 25 5)
(dnf f-rb           "rb"             () 20 5)
(dnf f-rx           "rx"             () 4 5)
(dnf f-lit          "lit"            () 20 12)
(dnf f-disp-n       "disp-n"         () 25 21)
(dnf f-disp-l       "disp-l"         () 20 16)
(dnf f-disp-c       "disp-c"         () 20 21)
(dnf f-disp-s       "disp-s"         () 15 16)
(dnf f-func         "func"           () 15 7)
(dnf f-tag          "tag"            () 8 4)

;;(dnf f-imm21-n      "imm21-n"        () 20 21)
;;(dnf f-imm16-l      "imm16-l"        () 15 16)
;;(dnf f-imm12-i      "imm12-i"        () 15 12)
;;(dnf f-imm21-c-high "imm21-c-high"   () 25 5)
;;(dnf f-imm21-c-low  "imm21-c-low"    () 15 16)
;;(dnmf f-imm21-c     "imm21-c"        () INT
;; (f-imm21-c-high f-imm21-c-low)
;; (sequence ()
;;	(set (ifield f-imm21-c-high) (and (sra (ifield f-imm21-c) (const 16)) (const #x1f)))
;;	(set (ifield f-imm21-c-low)  (and (ifield f-imm21-c) (const #xffff))))
;; (sequence ()
;;	(set (ifield f-imm21-c)
;;	 (sub (xor (const #x100000)
;;				 (or (sll (ifield f-imm21-c-high) (const 16))
;;					(ifield f-imm21-c-low)))
;;		(const #x100000))))
;;)
;;(dnf f-imm16-s-high "imm16-s-high"   () 25 5)
;;(dnf f-imm16-s-low  "imm16-s-low"    () 10 11)
;;(dnmf f-imm16-s     "imm16-s"        () INT
;; (f-imm16-s-high f-imm16-s-low)
;; (sequence ()
;;	(set (ifield f-imm16-s-high) (and (sra (ifield f-imm16-s) (const 11)) (const #x1f)))
;;	(set (ifield f-imm16-s-low)  (and (ifield f-imm16-s) (const #x7ff))))
;; (sequence ()
;;	(set (ifield f-imm16-s)
;;	 (sub (xor (const #x8000)
;;				 (or (sll (ifield f-imm16-s-high) (const 11))
;;					(ifield f-imm16-s-low)))
;;		(const #x8000))))
;;)

; Enums
(define-normal-insn-enum insn-op  "insn format enums" () OP_ f-opcode
  (.map .str (.iota 64))
)
(define-normal-insn-enum tag-op  "insn format enums" () TAG_ f-tag
  (.map .str (.iota 16))
)
(define-normal-insn-enum func-op  "insn format enums" () FUNC_ f-func
  (.map .str (.iota 128))
)
(define-normal-insn-enum lit-op  "insn format enums" () LIT_ f-lit
  (.map .str (.iota 4096))
)
(define-normal-insn-enum rx-op  "insn format enums" () RX_ f-rx ("0"))
(define-normal-insn-enum ra-op  "insn format enums" () RA_ f-ra ("0"))
(define-normal-insn-enum rb-op  "insn format enums" () RB_ f-rb ("0"))

;Hardware
(dnh h-pc "program counter" (PC) (pc) () () ())
(dnh h-gr "general registers"
     () ; attributes
     (register WI (32))
     (keyword "" ((sp 28) (ra 29) (tp 30) (rzero 31)
                  (r0 0) (r1 1) (r2 2) (r3 3)
                  (r4 4) (r5 5) (r6 6) (r7 7)
                  (r8 8) (r9 9) (r10 10) (r11 11)
                  (r12 12) (r13 13) (r14 14) (r15 15)
                  (r16 16) (r17 17) (r18 18) (r19 19)
                  (r20 20) (r21 21) (r22 22) (r23 23)
                  (r24 24) (r25 25) (r26 26) (r27 27)
                  (r28 28) (r29 29) (r30 30) (r31 31)
                  ))
     () ()
)

(dnh h-int21  "21 bit int"  () (immediate (INT 21)) () () ())
(dnh h-int16  "16 bit int"  () (immediate (INT 16)) () () ())
(dnh h-int12  "12 bit int"  () (immediate (INT 12)) () () ())
(dnh h-uint7  "7 bit uint"  () (immediate (UINT 7)) () () ())
(dnh h-uint4  "4 bit uint"  () (immediate (UINT 4)) () () ())

; Operand
(dnop rx           "destination register"         () h-gr f-rx)
(dnop ra           "source register 1"            () h-gr f-ra)
(dnop rb           "source register 2"            () h-gr f-rb)
(dnop imm21n       "21bit immediate value n-form" () h-int21 f-disp-n)
(dnop imm16l       "16bit immediate value l-form" () h-int16 f-disp-l)
(dnop imm21c       "21bit immediate value c-form" () h-int21 f-disp-c)
(dnop imm16s       "16bit immediate value s-form" () h-int16 f-disp-s)
(dnop lit          "12bit literal value i-form"   () h-int12 f-lit)
(dnop func         "func"                         () h-uint7 f-func)
(dnop tag          "tag"                          () h-uint4 f-tag)

; Instruction
; Instruction - ALU operation
(define-pmacro (alu-basic-op mnemonic sem tag r1 r2 r3)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/reg/reg")
   ()
   (.str mnemonic " $ra,$rb,$rx")
   (+ OP_57 r1 r2 FUNC_2 tag r3)
   (set r1 (sem r2 r3))
   ()
  )
  (dni (.sym mnemonic "i")
   (.str mnemonic "i reg/lit/reg")
   ()
   (.str mnemonic "i $ra,$lit,$rx")
   (+ OP_50 r1 lit tag r3)
   (set r1 (sem r2 lit))
   ()
  )
 )
)
(alu-basic-op add add  TAG_0  ra rb rx)
(alu-basic-op sub sub  TAG_1  ra rb rx)
(alu-basic-op sll sll  TAG_2  ra rb rx)
(alu-basic-op srl srl  TAG_3  ra rb rx)
(alu-basic-op sra sra  TAG_4  ra rb rx)
(alu-basic-op and and  TAG_5  ra rb rx)
(alu-basic-op ior or   TAG_6  ra rb rx)
(alu-basic-op xor xor  TAG_7  ra rb rx)

(define-pmacro (alu-cmp-op mnemonic sem tag r1 r2 r3)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/reg/reg")
   ()
   (.str mnemonic " $ra,$rb,$rx")
   (+ OP_57 r1 r2 FUNC_3 tag r3)
   (set r3 (sem r1 r2))
   ()
  )
  (dni (.sym mnemonic "i")
   (.str mnemonic "i reg/lit/reg")
   ()
   (.str mnemonic "i $ra,$lit,$rx")
   (+ OP_51 r1 lit tag r3)
   (set r3 (sem r1 lit))
   ()
  )
 )
)
(alu-cmp-op eq  eq  TAG_0 ra rb rx)
(alu-cmp-op ne  ne  TAG_1 ra rb rx)
(alu-cmp-op lt  lt  TAG_2 ra rb rx)
(alu-cmp-op le  le  TAG_3 ra rb rx)
(alu-cmp-op ult ltu TAG_4 ra rb rx)
(alu-cmp-op ule leu TAG_5 ra rb rx)
(alu-cmp-op gt  gt  TAG_6 ra rb rx)
(alu-cmp-op ugt gtu TAG_7 ra rb rx)

(define-pmacro (alu-ld-op mnemonic opcode r1 imm sft)
 (begin
  (dni mnemonic
   (.str mnemonic " imm21n/reg")
   ()
   (.str mnemonic " $imm21n,$rx" )
   (+ opcode imm r1)
   (set r1 (sll imm sft))
   ()
  )
 )
)
; maybe change if imm21n-low is unsigned needed
(alu-ld-op il OP_34 rx imm21n  (const 0))
(alu-ld-op ih OP_35 rx imm21n (const 11))

; Instruction - Memory Load Store operation
(define-pmacro (l-op mnemonic opcode r1 r2 imm)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/imm16l/reg")
   ()
   (.str mnemonic " $ra,$imm16l,$rx")
   (+ opcode r1 imm r2)
   (set r2 (mem WI (add USI r1 imm)))
   ()
  )
 )
)
(define-pmacro (s-op mnemonic opcode r1 r2 imm)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/reg/imm16s")
   ()
   (.str mnemonic " $ra,$rb,$imm16s")
   (+ opcode r1 r2 imm)
   (set (mem WI (add USI r1 imm)) r2)
   ()
  )
 )
)
(l-op  load  OP_54 ra rx imm16l)
(s-op store OP_31 ra rb imm16s)

; Instruction - Jump (with link) operation
; Instruction - Jump Register
(define-pmacro (jumplink-op mnemonic opcode r1 disp)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/imm21n")
   ()
   (.str mnemonic " $rx,$imm21n")
   (+ opcode r1 disp)
   (sequence ()
      (set r1 (add pc (const 4)))
      (set pc (add pc (add (const 4) (mul disp (const 4))))))
   ()
  )
 )
)
(define-pmacro (jr-op mnemonic opcode r1 r2)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/reg")
   ()
   (.str mnemonic " $ra,$rx")
   (+ opcode r1 LIT_0 TAG_0 r2)
   (sequence ()
      (set r2 (add pc (const 4)))
      (set pc r1))
   ()
  )
 )
)
(jumplink-op jl  OP_32 rx imm21n)
(jr-op jr   OP_48 ra rx)

; Instruction - Conditional Branch operation
(define-pmacro (cond-branch-op mnemonic opc r1 sem)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/imm21c")
   ()
   (.str mnemonic " $ra,$imm21c")
   (+ opc r1 imm21c)
   (if (sem r1 (const 0))
    (set pc (add pc (add (const 4) (mul imm21c (const 4))))))
   ()
  )
 )
)
(cond-branch-op beq   OP_17  ra   eq)
(cond-branch-op bne   OP_21  ra   ne)
(cond-branch-op blt   OP_18  ra   lt)
(cond-branch-op ble   OP_19  ra   le)
(cond-branch-op bgt   OP_23  ra   gt)
(cond-branch-op bge   OP_22  ra   ge)

; Instruction - SYSTEM operation
(define-pmacro (sys-op mnemonic r1 r2 tag)
 (begin
  (dni mnemonic
   (.str mnemonic " reg/tag/reg")
   ()
   (.str mnemonic " $ra,$tag,$rx")
   (+ OP_49 r1 LIT_0 tag r2)
   (nop)
   ()
  )
 )
)
(sys-op syscall RA_0 RX_0  TAG_0)
(sys-op sysret  RA_0 RX_0  TAG_1)
(sys-op sysr    RA_0 rx    TAG_8)
(sys-op sysw    ra   RX_0  TAG_9)

; Instruction - CONTROL operation
(define-pmacro (ctl-op mnemonic tag)
 (begin
  (dni mnemonic
   (.str mnemonic " tag")
   ()
   (.str mnemonic " $tag")
   (+ OP_3 RA_0 LIT_0 tag RX_0)
   (nop)
   ()
  )
 )
)
(ctl-op sync    TAG_0)
(ctl-op sync.v  TAG_8)
(ctl-op sync.i  TAG_15)

; instruction nop
(dni nop
  "nop"
  ()
  "nop"
  (+ OP_0 imm21n RX_0)
  (nop)
  ()
)

